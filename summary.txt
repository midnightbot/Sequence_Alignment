***************************************************************************************************************

CREATED BY : ANISH RAJESH ADNANI
COURSE CODE : CSCI 570
COURSE NAME : ANALYSIS OF ALGORITHMS
****************************************************************************************************************
****************************************************************************************************************
GOAL OF THE PROJECT WAS TO FIND OPTIMAL SEQUENCE ALIGNMENT BETWEEN TWO STRINGS

COMMENTS ON WHY EFFICIENT AND BASIC VERSIONS HAVE DIFFERENT MEMORY AND TIME PLOTS
THERE ARE TWO APPROACHES TO ACHIEVE THE CODE
1. APPROACH 1 - TIME EFFICIENT
TIME EFFICIENT APPROACH IS A BASIC RECURSIVE APPROACH USED TO SOLVE THE SEQUENCE ALIGNMENT PROBLEM.
CONSIDER A "DP" ARRAY (2-D ARRAY OF SIZE (M+1)*(N+1)) WHERE M = SIZE OF WORD1, N = SIZE OF WORD2.
DP[I][J] REPRESENTS THE MINIMUM ALIGNMENT COST BETWEEN STRINGS X1...XI AND Y1...YJ
THERE ARE FIXED MISMATCH COST FOR EVERY CHARACTER PAIR COMBINATION AND A FIXED GAP PENALTY

FORMING THE RECURSIVE RELATION
CLEARLY SEEN EITHER THE LAST TWO CHARACTERS OF THE WORDS WILL BE MATCHED OR THEY WILL NOT BE MATCHED
CASE1 : (IF MATCHED) THE NEW PROBLEM WOULD BE X1..Xi-1 and Y1..Yj-1
CASE2 : (IF NOT MATCHED) THIS IS FURTHER DIVIDED INTO TWO CASE
	Case2.1 : NEW PROBLEM WOULD BE X1...Xi-1 and Y1...Yj, i.e, Xi aligned with a gap penalty
	Case 2.2 : NEW PROBELM WOULD BE X1...Xi and Y1...Yj-1, i.e, Yi aligned with a gap penalty

THEREFORE OUR RECURSIVE RELATION

DP[I][J] = MIN (DP[I-1][J-1]+MISMATCH[X[I-1]][Y[J-1]], DP[I-1][J]+DELTA, DP[I][J-1]+DELTA)  (FORMULA 1)

FIND OPTIMAL SOLUTION FROM DP ARRAY
FINDING OPTIMAL SOLUTION REQUIRES TOP DOWN TRAVERSAL ON THE DP ARRAY
I.E IF DP[X][Y] == DP[X-1][Y-1] + MISMATCH[X[I-1]][Y[J-1]]:
	##THIS INDICATES CHARCTER Xth OF WORD1 IS ALIGNED WITH CHARCATER Yth WITH WORD2
	## HENCE WORD1[X-1] AND WORD2[Y-1] ARE APPENDED IN THE FINAL ALIGNEMENTS
    ELIF DP[X][Y] == DP[X-1][Y] + DELTA:
	## THIS INDICATES CHARACTER Xth OF WORD1 IS ALIGNED WITH A GAP
	## HENCE WORD1[X-1] AND - ARE APPENDED IN THE FINAL ALIGNMENTS
    ELIF DP[X][Y] == DP[X][Y-1] + DELTA:
	## THIS INDICTAES CHARACTER Yth OF WORD2 IS ALIGNED WITH A GAP
	## HENCE - AND WORD2[Y-1] ARE APPENDED IN THE FINAL ALIGNMENTS

SPACE COMPLEXITY
AS WE ARE CREATING A 2D DP ARRAY OF SIZE (M+1)*(N+1)
SPACE COMPLEXITY OF THIS ALGORITHM IS O(M*N)

TIME COMPLEXITY
CONSIDERING THE FACT THAT WE OUR SOLVING EVERY SUBPROBLEM DP[I][J]
THERE ARE M*N SUBPROBLEMS, EACH TAKING O(1) TIME
THEREFORE TIME COMPLEXITY OF THE ALGORITHM WOULD BE O(M*N)


2. APPROACH 2 - SPACE EFFICIENT
AS SEEN FROM THE ABOVE RECURSIVE RELATION (FORMULA 1), TO FILL ANY ROW SAY ROW 'M' WE ONLY NEED VALUES FROM ROW 'M-1'
SO WHY WASTE SPACE IN STORING THE WHOLE DP ARRAY, AND NOT JUST USE 2 ROWS TO FIND THE OPTIMAL ANSWER
WE CAN FIND THE OPTIMAL ANSWER USING THE ABOVE MENTIONED STRATEGY, BUT WE WILL NOT BE ABLE TO FIND OPTIMAL ALIGNMENT WITHOUT STORING THE WHOLE DP ARRAY

AN INSIGHTFUL APPROACH WOULD BE TO USE DIVIDE AND CONQUER TO SOLVE TO GIVEN PROBLEM
BUT THE QUESTION THAT IS TO BE ANSWERED IS, WHERE TO SPLIT THE WORDS?
WE CAN SPLIT THE WORD1 AT ITS MID POINT, BUT WE DO NOT KNOW THE CORRESPODING SPLIT POINT OF WORD2, AS THE SPLIT POINT OF WORD2 MUST BE ON THE OPTIMAL ALIGNMENT

LET (Q,K) BE THE SPLIT POINT WHERE INDEX Q IS LEN(X)/2 AND WE NEED TO FIND K, SPLIT INDEX OF WORD2
SAY F(Q,K) -> DENOTE THE ALIGNMENT COST FROM X1..XQ AND Y1..YK
G(Q,K) - > DENOTE THE ALIGNMENT COST FROM XQ+1..XM AND YK+1..YN 

THERE K WILL BE THE INDEX THAT MINIMIZES (F(Q,K) + G(Q,K))
AS WE ONLY NEED VALUES OF THE DP ARRAY HERE TO FIND WHICH VALUE IS MINIMUM, WE CAN JUST USE TWO ROWS TO FIND THE VALUES AS MENTIONED ABOVE RATHER THAN STORING THE WHOLE DP ARRAY

THE WORDS ARE DIVIDING UNTIL IT HITS ONE OF THE BASE CASES
1. LEN(WORD1) OR LEN(WORD2) = 0
2. LEN(WORD1) OR LEN(WORD2) = 1
IN THE ABOVE MENTIONED SCENARIOS WE SOLVE THE ALIGNMENT PROBLEM DIRECTLY RATHER THAN DIVIDING IT FURTHER

PSEUDOCODE

DIVIDE(WORD1,WORD2):
	IF THIS BASE CASE? YES:
		SOLVE DIRECTLY RETURN ALIGNMENT,COST
	ELSE:
		Q = LEN(WORD1)/2
		K = FIND_SPLIT_POINT(WORD2)
		ALIGNMENT,COST = DIVIDE(WORD1[0:Q],WORD2[0:K]) + DIVIDE(WORD1[Q:],WORD2[K:])

		RETURN ALIGNMENT,COST

THEREFORE WE ARE USING DIVIDE AND CONQUER TO SOLVE THE PROBLEM


DIVIDE STEP USES DYNAMIC PROGRAMMING TO FIND THE OPTIMAL SPLIT POINT
CONQUER STEP JUST CONCATENATES THE ANSWER FROM ALL SUBPROBLEMS

SPACE COMPLEXITY:
AS SEEN DYNAMIC PROGRAMMING IS JUST USED IN THE DIVIDE STEP, WE CAN FIND THE OPTIMAL VALUES USING ONLY 2 ROWS OR 2 COLUMNS
THEREFORE SPACE COMPLEXITY WILL BE LINEAR O(M+N)

TIME COMPLEXITY:
WORK DONE AT EACH STEP REDUCES TO HALF OF THE PREVIOUS STEP (AS SUBPROBLEM IS DIVIDING THE PROBLEM INTO HALVES)
WORK IS DONE TO FIND THE VALUES OF THE DP ARRAY
WORK DONE : CMN + CMN/2 + CMN/4 + .......   = O(2CMN)

HENCE TO CONCLUDE
                                        SPACE COMPLEXITY                   TIME COMPLEXITY

TIME EFFICIENT ALGORITHM                    O(MN)                             O(CMN)
SPACE EFFICIENT ALGORITHM                   O(M+N)                            O(2CMN)

HENCE THE ABOVE EXPLANATIONS JUSTITY DIFFERENT MEMORY AND TIME GRAPHS AS ATTACHED IN THE ZIP FILE
*********************************************************************************************************************************8

